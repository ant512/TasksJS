<html>
<head>
<script>

var Tasks = {
	TaskList: function() {
		this.taskList = new Array();
	},

	Task: function(name, startDate, duration, parent) {
		this.name = name;
		this.startDate = startDate;
		this.dependencies = new Array();
		this.duration = duration;
		this.parent = parent;
	},
	
	/**
	 * Owning task will start when the task it is dependent on finishes.
	 * @param owner The task that owns this dependency.
	 * @param dependentOn Task that this task is dependent on.
	 */
	FinishToStartDependency: function(owner, dependentOn) {
		this.owner = owner;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task will finish when the task it is dependent on finishes.
	 * @param owner The task that owns this dependency.
	 * @param dependentOn Task that this task is dependent on.
	 */
	FinishToFinishDependency: function(owner, dependentOn) {
		this.owner = owner;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task will start when the task it is dependent on starts.
	 * @param owner The task that owns this dependency.
	 * @param dependentOn Task that this task is dependent on.
	 */
	StartToStartDependency: function(owner, dependentOn) {
		this.owner = owner;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task will finish when the task it is dependent on starts.
	 * @param owner The task that owns this dependency.
	 * @param dependentOn Task that this task is dependent on.
	 */
	StartToFinishDependency: function(owner, dependentOn) {
		this.owner = owner;
		this.dependentOn = dependentOn;
	}
}


/** TaskList Methods */

Tasks.TaskList.prototype.at = function(index) {
	return this.taskList[index];
}

Tasks.TaskList.prototype.getCount = function() {
	return this.taskList.length;
}

Tasks.TaskList.prototype.add = function(task) {
	this.taskList.push(task);
}

/**
 * Recalculates the start date of all tasks in the list.  Relies on the sort()
 * function to ensure that all tasks on which task T is dependent on are
 * calculated before T is reached.  Recalculating dates becomes a simple matter
 * of asking the task's dependencies for their start dates, and choosing the
 * latest date.
 */
Tasks.TaskList.prototype.recalculateDates = function(earliestDate) {
	this.sort();
	
	for (var i in this.taskList) {
		this.taskList[i].recalculateStartDate(earliestDate);
	}
}

/**
 * Topological sort of the task list.  Each task is ordered so that the tasks
 * that it depends on come before it in the list.  Therefore, the first task(s)
 * in the list will always be those tasks that are not dependent on any other.
 */
Tasks.TaskList.prototype.sort = function() {
	var rootTasks = new Array();
	var removedDependencyCounts = new Array();
	var sortedTasks = new Array();
	
	// Create list of tasks that are not dependent on any other
	for (var i in this.taskList) {
		if (!this.taskList[i].hasDependencies()) {
			rootTasks.push(this.taskList[i]);
		}
		
		removedDependencyCounts[i] = 0;
	}
	
	// Sort the graph
	while (rootTasks.length > 0) {
		
		// Remove the first task from the root list
		var task = rootTasks[0];
		rootTasks.splice(0, 1);
		
		// Add the task to the sorted list
		sortedTasks.push(task);
		
		// Loop through the tasks that are dependent on this, reducing their
		// counts and, for each task with no subsequent dependencies, adding it
		// to the sorted list
		for (var i in this.taskList) {
			var dependencies = this.taskList[i].getDependencies();
			
			for (var j in dependencies) {
				if (dependencies[j].getDependentOn() == task) {
					removedDependencyCounts[i]++;
					
					if (dependencies.length == removedDependencyCounts[i]) {
						rootTasks.push(this.taskList[i]);
					}
				}
			}
		}
	}
	
	this.taskList = sortedTasks;
}


/** Task Methods **/

Tasks.Task.prototype.hasDependencies = function() {
	return (this.dependencies.length > 0);
}

Tasks.Task.prototype.addDependency = function(dependency) {
	this.dependencies.push(dependency);
}

Tasks.Task.prototype.getName = function() {
	return this.name;
}

Tasks.Task.prototype.getDependencies = function() {
	return this.dependencies;
}

Tasks.Task.prototype.getStartDate = function() {
	return this.startDate;
}

Tasks.Task.prototype.getEndDate = function() {
	return new Date(this.startDate.getTime() + this.duration);
}

Tasks.Task.prototype.getDuration = function() {
	return this.duration;
}

Tasks.Task.prototype.recalculateStartDate = function(earliestDate) {
	var latestDate = earliestDate;
	
	for (var i in this.dependencies) {
		var dependencyDate = this.dependencies[i].getStartDate();
		
		if (dependencyDate > latestDate) {
			latestDate = dependencyDate;
		}
	}
	
	this.startDate = latestDate;
}


/** FinishToStartDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.FinishToStartDependency.prototype.getStartDate = function() {
	return this.dependentOn.getEndDate();
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.FinishToStartDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.FinishToStartDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** FinishToFinishDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.FinishToFinishDependency.prototype.getStartDate = function() {
	return new Date(this.dependentOn.getEndDate().getDate() - this.owner.getDuration());
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.FinishToFinishDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.FinishToFinishDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** StartToStartDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.StartToStartDependency.prototype.getStartDate = function() {
	return new Date(this.dependentOn.getStartDate());
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.StartToStartDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.StartToStartDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** StartToFinishDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.StartToFinishDependency.prototype.getStartDate = function() {
	return new Date(this.dependentOn.getStartDate().getTime() - this.owner.getDuration());
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.StartToFinishDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.StartToFinishDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


var taskList = new Tasks.TaskList();
taskList.add(new Tasks.Task("Task 1", new Date(2010, 0, 1, 9, 30, 0, 0), 3600000, null));
taskList.add(new Tasks.Task("Task 2", new Date(2010, 0, 1, 9, 30, 0, 0), 3600000, null));
taskList.add(new Tasks.Task("Task 1.1", new Date(2010, 0, 1, 9, 30, 0, 0), 360000, taskList.at(0)));

taskList.at(1).addDependency(new Tasks.FinishToStartDependency(taskList.at(1), taskList.at(0)));

alertTasks(taskList);

taskList.recalculateDates(new Date(2010, 0, 1, 9, 30, 0, 0));

alertTasks(taskList);

function alertTasks(tasks) {
	var str = "";
	for (var i = 0; i < tasks.getCount(); ++i) {
		str += tasks.at(i).getName() + ' ' + tasks.at(i).getStartDate() + '\n';
	}
	alert(str);
}

</script>
</head>

<body>

</body>
</html>