<html>
<head>
<script>

var Tasks = {
	TaskList: function() {
		this.taskList = new Array();
	},

	/**
	 * Task object.
	 * @param name Name of the task.
	 * @param duration The length of the task in milliseconds.
	 * @param orderNumber The order number of the task when it is displayed.
	 */
	Task: function(name, duration, orderNumber) {
		this.name = name;
		this.startDate = new Date();
		this.dependencies = new Array();
		this.duration = duration;
		this.orderNumber = orderNumber;
	},
	
	/**
	 * Owning task will start when the task it is dependent on finishes.
	 * @param dependentOn Task that this task is dependent on.
	 */
	FinishToStartDependency: function(dependentOn) {
		this.owner = null;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task will finish when the task it is dependent on finishes.
	 * @param dependentOn Task that this task is dependent on.
	 */
	FinishToFinishDependency: function(dependentOn) {
		this.owner = null;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task will start when the task it is dependent on starts.
	 * @param dependentOn Task that this task is dependent on.
	 */
	StartToStartDependency: function(dependentOn) {
		this.owner = null;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task will finish when the task it is dependent on starts.
	 * @param dependentOn Task that this task is dependent on.
	 */
	StartToFinishDependency: function(dependentOn) {
		this.owner = null;
		this.dependentOn = dependentOn;
	},
	
	/**
	 * Owning task is a child of the task it is dependent on.  This simulates
	 * a tree structure without storing the data as a tree.  The most intensive
	 * calculations require the tasks in the form of a list; the tree is mainly
	 * for visualising the data and for (in this particular case) ensuring that
	 * child tasks start at the same time as their parent (at the earliest) and
	 * that parent tasks start at the same time as their first child.
	 * @param dependentOn Task that this task is dependent on.
	 */
	ParentChildDependency: function(dependentOn) {
		this.owner = null;
		this.dependentOn = dependentOn;
	}
}


/** TaskList Methods */

Tasks.TaskList.prototype.at = function(index) {
	return this.taskList[index];
}

Tasks.TaskList.prototype.getCount = function() {
	return this.taskList.length;
}

Tasks.TaskList.prototype.add = function(task) {
	this.taskList.push(task);
}

/**
 * Recalculates the start date of all tasks in the list.  Relies on the sort()
 * function to ensure that all tasks on which task T is dependent on are
 * calculated before T is reached.  Recalculating dates becomes a simple matter
 * of asking the task's dependencies for their start dates, and choosing the
 * latest date.
 */
Tasks.TaskList.prototype.recalculateDates = function(earliestDate) {
	this.sort();
	
	for (var i in this.taskList) {
		this.taskList[i].recalculateStartDate(earliestDate);
	}
}

/**
 * Topological sort of the task list.  Each task is ordered so that the tasks
 * that it depends on come before it in the list.  Therefore, the first task(s)
 * in the list will always be those tasks that are not dependent on any other.
 */
Tasks.TaskList.prototype.sort = function() {
	var rootTasks = new Array();
	var removedDependencyCounts = new Array();
	var sortedTasks = new Array();
	
	// Create list of tasks that are not dependent on any other
	for (var i in this.taskList) {
		if (!this.taskList[i].hasDependencies()) {
			rootTasks.push(this.taskList[i]);
		}
		
		removedDependencyCounts[i] = 0;
	}
	
	// Sort the graph
	while (rootTasks.length > 0) {
		
		// Remove the first task from the root list
		var task = rootTasks[0];
		rootTasks.splice(0, 1);
		
		// Add the task to the sorted list
		sortedTasks.push(task);
		
		// Loop through the tasks that are dependent on this, reducing their
		// counts and, for each task with no subsequent dependencies, adding it
		// to the sorted list
		for (var i in this.taskList) {
			var dependencies = this.taskList[i].getDependencies();
			
			for (var j in dependencies) {
				if (dependencies[j].getDependentOn() == task) {
					removedDependencyCounts[i]++;
					
					if (dependencies.length == removedDependencyCounts[i]) {
						rootTasks.push(this.taskList[i]);
					}
				}
			}
		}
	}
	
	this.taskList = sortedTasks;
}

/**
 * Gets a list of tasks (as an array) that belong to the specified parent.  The
 * tasks are ordered by their orderNumber property.  If parent is null, the
 * top-level (tasks without parents) are retrieved.
 * @param parent The parent task for which the child list is to be retrieved.
 * If this is null, the top-level tasks are returned.
 * @return An array of tasks belonging to the specified parent.
 */
Tasks.TaskList.prototype.getTasksForParent = function(parent) {
	var children = new Array();
	
	for (var i in this.taskList) {
		var task = this.taskList[i];
		var isChild = false;
		
		for (var j in task.getDependencies()) {
			var dependency = task.getDependencies()[j];
			
			// Check if the dependency is a ParentChildDependency object.
			// This (typechecking to determine behaviour) is ugly, but it saves
			// us maintaining a real tree structure and trying to duplicate the
			// dependency behaviour within that structure
			if (!(dependency instanceof Tasks.ParentChildDependency)) continue;
							
			// Task is a child of *something*.
			isChild = true;
			
			// If we're looking for top-level tasks, this task is no good to us
			if (parent == null) break;
			
			// Check if the task is a child of the specified parent
			if (dependency.getDependentOn() != parent) continue;
			
			// Task is a child of the parent, so remember it
			children.push(task);
		}
		
		// If we want them, did we find a top-level task?
		if (!isChild && parent == null) {
			children.push(task);
		}
	}
	
	// Sort the child list by order number
	children.sort(function(a, b) { return a.getOrderNumber() - b.getOrderNumber(); });
	
	return children;
}


/** Task Methods **/

/**
 * Check if the task has dependencies or not.
 * @return True if the task has dependencies, or false if not.
 */
Tasks.Task.prototype.hasDependencies = function() {
	return (this.dependencies.length > 0);
}

/**
 * Adds a dependency to this task's list of dependencies.  Automatically sets
 * the dependency's owner to the current task.
 * @param dependency The dependency to add.
 */
Tasks.Task.prototype.addDependency = function(dependency) {
	
	// We need to ensure that the dependency knows it is owned by this task
	// before we add it to the task's list of dependencies.
	dependency.setOwner(this);
	
	this.dependencies.push(dependency);
}

/**
 * Gets the name of the task.
 * @return The name of the task.
 */
Tasks.Task.prototype.getName = function() {
	return this.name;
}

/**
 * Gets the order number of the task.  The order number is used to display tasks
 * in the correct order.  Tasks should not have the same order number their
 * siblings (ie. other tasks that have a ParentChildDependency on the same task
 * as each other).
 * @return The order number of the task.
 */
Tasks.Task.prototype.getOrderNumber = function() {
	return this.orderNumber;
}

/**
 * Gets the list of dependencies that this task has.
 * @return The list of dependencies of this task.
 */
Tasks.Task.prototype.getDependencies = function() {
	return this.dependencies;
}

/**
 * Gets the date on which the task starts.
 * @return The start date of the task.
 */
Tasks.Task.prototype.getStartDate = function() {
	return this.startDate;
}

/**
 * Gets the end date of the task.
 * @return The end date of the task.
 */
Tasks.Task.prototype.getEndDate = function() {
	return new Date(this.startDate.getTime() + this.duration);
}

/**
 * Gets the duration of the task in milliseconds.
 * @return The duration of the task in milliseconds.
 */
Tasks.Task.prototype.getDuration = function() {
	return this.duration;
}

/**
 * Recalculates the start date of the task based on the start dates of its
 * dependencies.  The earliest date that the task will use as its start date
 * (in the situation where it has no dependencies, for example) is the value
 * passed as earliestDate.
 * @param earliestDate The earliest date that the task can use as its start
 * date.
 */
Tasks.Task.prototype.recalculateStartDate = function(earliestDate) {
	var latestDate = earliestDate;
	
	for (var i in this.dependencies) {
		var dependencyDate = this.dependencies[i].getStartDate();
		
		if (dependencyDate > latestDate) {
			latestDate = dependencyDate;
		}
	}
	
	this.startDate = latestDate;
}


/** FinishToStartDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.FinishToStartDependency.prototype.getStartDate = function() {
	return this.dependentOn.getEndDate();
}

/**
 * Set the owner of the dependency.  This is done automatically by the Task
 * object's addDependency() method and shouldn't be used elsewhere.
 * @param owner The owner of the dependency.
 */
Tasks.FinishToStartDependency.prototype.setOwner = function(owner) {
	this.owner = owner;
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.FinishToStartDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.FinishToStartDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** FinishToFinishDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.FinishToFinishDependency.prototype.getStartDate = function() {
	return new Date(this.dependentOn.getEndDate().getDate() - this.owner.getDuration());
}

/**
 * Set the owner of the dependency.  This is done automatically by the Task
 * object's addDependency() method and shouldn't be used elsewhere.
 * @param owner The owner of the dependency.
 */
Tasks.FinishToFinishDependency.prototype.setOwner = function(owner) {
	this.owner = owner;
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.FinishToFinishDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.FinishToFinishDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** StartToStartDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.StartToStartDependency.prototype.getStartDate = function() {
	return new Date(this.dependentOn.getStartDate());
}

/**
 * Set the owner of the dependency.  This is done automatically by the Task
 * object's addDependency() method and shouldn't be used elsewhere.
 * @param owner The owner of the dependency.
 */
Tasks.StartToStartDependency.prototype.setOwner = function(owner) {
	this.owner = owner;
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.StartToStartDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.StartToStartDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** StartToFinishDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.StartToFinishDependency.prototype.getStartDate = function() {
	return new Date(this.dependentOn.getStartDate().getTime() - this.owner.getDuration());
}

/**
 * Set the owner of the dependency.  This is done automatically by the Task
 * object's addDependency() method and shouldn't be used elsewhere.
 * @param owner The owner of the dependency.
 */
Tasks.StartToFinishDependency.prototype.setOwner = function(owner) {
	this.owner = owner;
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.StartToFinishDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.StartToFinishDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


/** ParentChildDependency Methods **/

/**
 * Get the start date of the task.
 * @return The start date of the task.
 */
Tasks.ParentChildDependency.prototype.getStartDate = function() {
	return this.dependentOn.getStartDate();
}

/**
 * Set the owner of the dependency.  This is done automatically by the Task
 * object's addDependency() method and shouldn't be used elsewhere.
 * @param owner The owner of the dependency.
 */
Tasks.ParentChildDependency.prototype.setOwner = function(owner) {
	this.owner = owner;
}

/**
 * Get the task that owns the dependency.
 * @return The task that owns the dependency.
 */
Tasks.ParentChildDependency.prototype.getOwner = function() {
	return this.owner;
}

/**
 * Get the task that the owner is dependent on.
 * @return The task that the owner is dependent on.
 */
Tasks.ParentChildDependency.prototype.getDependentOn = function() {
	return this.dependentOn;
}


var taskList = new Tasks.TaskList();

taskList.add(new Tasks.Task("Task 1", 3600000, 1));
taskList.add(new Tasks.Task("Task 2", 3600000, 2));
taskList.add(new Tasks.Task("Task 1.1", 3600000, 1));
taskList.add(new Tasks.Task("Task 1.2", 3600000, 2));

// Make task 2 dependent on task 1
taskList.at(1).addDependency(new Tasks.FinishToStartDependency(taskList.at(0)));

// Make tasks 1.1 and 1.2 children of task 1
taskList.at(2).addDependency(new Tasks.ParentChildDependency(taskList.at(0)));
taskList.at(3).addDependency(new Tasks.ParentChildDependency(taskList.at(0)));

// Make task 1.2 dependent on task 1.1
taskList.at(3).addDependency(new Tasks.FinishToStartDependency(taskList.at(2)));

// Display task list before date calculations
//alertTaskList(taskList);

// Recalculate the dates of all tasks, using the submitted date as the start
// date of the project
taskList.recalculateDates(new Date(2010, 0, 1, 9, 30, 0, 0));

// Display task list post date calculations
alertTaskList(taskList);

// Get the top-level tasks
alertTaskArray(taskList.getTasksForParent(null));

// Get the children of task 1
alertTaskArray(taskList.getTasksForParent(taskList.at(0)));


function alertTaskList(tasks) {
	var str = "";
	for (var i = 0; i < tasks.getCount(); ++i) {
		str += tasks.at(i).getName() + ' ' + tasks.at(i).getStartDate() + '\n';
	}
	alert(str);
}

function alertTaskArray(tasks) {
	var str = "";
	for (var i in tasks) {
		str += tasks[i].getName() + ' ' + tasks[i].getStartDate() + '\n';
	}
	alert(str);
}

</script>
</head>

<body>

</body>
</html>